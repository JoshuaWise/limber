/**
 * Retrieves the first element of a list. 
 * Provided as a semantic opposite of last().
 */
first(list)
	return list[0]
	
/**
 * Returns a clone of the given source, but with the element at index `index`
 * replaced by `value`.
 */
change(source, index, value)
	expr = clone(source)
	expr[index] = value
	return expr
	
/**
 * Returns a copy of a portion of a list. Mirrors the functionality and
 * implementation of JavaScript's Array.prototype.slice. If only the first
 * argument is provided, a shallow copy of the list is returned.
 */
slice(list, start = 0, end = null)
	len = length(list)
	end = end == null ? len : end
	unless start is a 'unit' and end is a 'unit' and unit(start) == '' and unit(end) == ''
		error('second and third argumetns of slice() must be numbers')
	k = start < 0 ? max(len + start, 0) : min(start, len)
	final = end < 0 ? max(len + end, 0) : min(end, len)
	result = ()
	return result if k >= final
	for i in (k ... final)
		push(result, list[i])
	return result
	
/**
 * Sorts a list IN PLACE (no copy is made), and returns the list.
 * The default sorting function compares numbers by value, and strings by
 * Unicode position.
 *
 * Examples:
 * 		sort(1 5 7 -15 845) => (-15 1 5 7 845)
 * 		sort('zebra' 'apple' 'blueberry') => ('apple' 'blueberry' 'zebra')
 * 		sort('90' '600' '77') => ('600' '77' '90')
 * 
 * If you specify a sorting function as a second argument, that function should
 * return true only if its first argument is equal to or less than the second
 * argument. Otherwise, it should return false.
 */
sort(list, fn = null)
	len = length(list)
	return list unless len > 1
	
	if fn == null
		fn = @(a, b) {
			a <= b
		}
		
	for i in (1 ... len)
		value = list[i]
		actual-j = i - 1
		broke-loop = false
		for j in (actual-j .. -1)
			unless broke-loop
				actual-j = j
				if j < 0 or fn(list[j], value)
					broke-loop = true 
				else
					list[j + 1] = list[j]
		list[actual-j + 1] = value
	return list
	
/**
 * If the given value is a px unit, or can be converted to px while maintaining
 * its value, convert it to px and return it. Otherwise, null is returned.
 */
force-px(value)
	if (length(value) == 1 and value is a 'unit' and (unit(value) == 'px' || value == 0))
		return (value)px
	else
		return null
		
/**
 * Given a rule hash, returns a list with two elements.
 * That list's first element is the rule's first property's name (eg, font-size)
 * The list's second element is the rule's first property's value (eg, 40px)
 * Example:
 * 		rule = {selector: 'h1', properties: ()}
 * 		push(rule.properties, {margin: 40px})
 * 		push(rule.properties, {text-align: left})
 * 		push(rule.properties, {width: 100%})
 * 		first-property(rule) => ('margin' 40px)
 */
first-property(rule)
	properties = rule.properties
	len = length(properties)
	return null if len == 0
	return property value for property, value in properties if len == 1
	return property value for property, value in entry for entry in properties
	
/**
 * Given a list of rule hashes where each rule only contains one property,
 * returns a new list of rule hashes, which is logically equivilent, but
 * generally smaller in size.
 * Example:
 * 		rules = ()
 * 		push(rules, {selector: 'h1', properties: {font-size: 15px}})
 * 		push(rules, {selector: 'p', properties: {font-size: 15px}})
 * 		push(rules, {selector: 'h1', properties: {margin: auto}})
 * 		push(rules, {selector: 'h1', properties: {width: 100%}})
 * 		combine-rules(rules) => (
 * 							{selector: 'h1, p', properties: {font-size: 15px}}
 * 							{selector: 'h1', properties: (
 * 								{margin: auto}
 * 								{width: 100%}
 * 							)}
 * 						)
 */
combine-rules(rules)
	len = length(rules)
	return () unless len > 0
	
	rules = clone(rules)
	selectors = {}
	for i in (0 ... len)
		rule = rules[i]
		unless rule == null
			matched-selectors = clone(rule.selector)
			relevant-entry = first-property(rule)
			for j in (i + 1 ... len)
				other-rule = rules[j]
				unless other-rule == null
					if first-property(other-rule) == relevant-entry
						push(matched-selectors, other-rule.selector) unless other-rule.selector in matched-selectors
						rules[j] = null
			selector = join(', ', sort(matched-selectors))
			selectors[selector] = () unless selector in selectors
			entry = {}
			entry[relevant-entry[0]] = relevant-entry[1]
			push(selectors[selector], entry)
	results = ()
	for selector, properties in selectors
		push(results, {
			selector: selector
			properties: properties
		})
	return results
	
/**
 * Given a rule hash, print the rule in actual CSS.
 * Example:
 *  	print-rule({selector: 'h1', properties: ({font-size: 40px} {left: 0})})
 * 	=>	h1 {
 * 			font-size: 40px;
 * 			left: 0;
 * 		}
 */
print-rule(rule)
	selector = rule.selector
	properties = rule.properties
	{selector}
		{property} value for property, value in properties
		
/**
 * Used internally for extracting priority flags from mixin arguments.
 */
-extract-priority(last-group)
	return last(last-group) == !important ? pop(last-group) : unquote('')
	
